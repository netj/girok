#!/usr/bin/env bash
# girok -- backup manager
  Version=1.20060603
# Author: Jaeho Shin <netj@sparcs.org>
# Refined: 2006-04-06
# Created: 2004-08-24

set -e

BackupRoot=${BackupRoot:-/backup}; export BackupRoot
BackupArchive=${BackupArchive:-$BackupRoot/archive}
BackupTable=${BackupTable:-$BackupRoot/backuptab}

foreach_backup() {
    local line=0 rest= prefix= period= options= paths=
    while read; do
        let ++line
        [ "$REPLY" = "${REPLY#\#}" -o -z "$REPLY" ] || continue
        rest=$REPLY
        prefix=${rest%%	*}
        rest=${rest#$prefix	}
        periodspec=${rest%%	*}
        rest=${rest#$periodspec	}
        options=${rest%%	*}
        paths=${rest#$options	}
        if [ -n "$prefix" -a -n "$periodspec" -a -n "$paths" ]; then
            "$@"
        else
            echo "$BackupTable: line $line: syntax error" >&2
        fi
    done <"$BackupTable"
}

Here=$PWD
Base=`cd "$(dirname "$0")" && pwd`
Name=`basename "$0"`
Args=("$@")
error() { echo "$Name: $@" >&2; }

cd "$BackupArchive"
case "$Name" in
    backup)
    usage() {
        cat <<EOF
girok $Version -- perform backup
Usage: backup { <prefix> }

Create backup archives for <prefix>es defined in $BackupTable.
Each line in $BackupTable defines an archive series.  Each must have four
fields separated by tab character: prefix, period, options, and paths.
Lines that begin with a \# are ignored.  Each archive is created under
$BackupArchive/ with the specified prefix, period, and options by girok(1).

For example, the following defines an archive series that will be stored as
$BackupArchive/home/netj-*-*.tar.gpg.
-->8--
home/netj	%m/3	-e netj	/home/netj
--8<--
See girok(1) for more information about periods and options.
EOF
        [ $# -gt 0 ] && error "$@"
        exit 2
    }
    [ $# -eq 0 ] && usage

    finish() {
        local exitcode=$?
        trap "exit $exitcode" EXIT ERR HUP INT TERM
        rm -f $tmp
        echo "ends   at `date +'%F %T %z'`"
        exit $exitcode
    }
    # prepare output holder
    tmp=`mktemp /tmp/backup.XXXXXX`
    trap finish EXIT ERR HUP INT TERM

    failure=0
    do_backup() {
        local a=
        for a in "${Args[@]}"; do
            [ `expr "$prefix" : "$a"` -eq ${#prefix} ] || continue
            printf "* %-16s" "$prefix:"
            if eval "'${Base/"'"/"'\\''"}'/girok $options \
                    $prefix $periodspec $paths" >$tmp 2>&1; then
                printf "%28s %5s" \
                    `grep 'containing:$' $tmp | sed -e 's/(\([^)]*\)).*/\1/'`
                head -1 $tmp | sed -e 's/^.*://'
            else
                echo FAILED
                let ++failure
                cat $tmp 2>/dev/null
            fi
        done
    }

    echo "girok $Version"
    echo "backup ${Args[@]}"
    echo "begins at `date +'%F %T %z'`"
    echo

    echo "= backups ="
    foreach_backup do_backup
    echo

    echo "= disk usages ="
    df -h `find "$BackupArchive" -type d` \
    | tail +2 | sort | uniq | sed -e 's/^/* /'
    echo

    exit $failure
    ;;


    recover)
    usage() {
        cat <<EOF
girok $Version -- recover files
Usage: recover [ -t [[CC]YY]MMDDhhmm[.ss] ] { <path> }

Finds and extracts given paths from backup archives,
from the most recent backup before the given time.
Current date and time are used if not specified.
EOF
        [ $# -gt 0 ] && error "$@"
        exit 2
    }
    # process options
    while getopts "t:" o; do
        case "$o" in
            t) when=$OPTARG ;;
        esac
    done
    shift $(($OPTIND - 1))
    [ $# -eq 0 ] && usage
    when=${when:-`date +%Y%m%d%H%M.%S`}
    # prepare timestamp
    timestamp=`mktemp /tmp/recover.XXXXXX`
    trap "rm -f $timestamp" EXIT ERR HUP INT TERM
    touch -m -t $when $timestamp 2>/dev/null ||
        usage "specify time in [[CC]YY]MMDDhhmm[.ss]"

    timefmt="%Y-%m-%dT%H:%M:%S"
    # GNU is default
    mtime() { echo "`date -r $arc +$timefmt`"; }
    chronological() { xargs -0r ls -tr; }
    # detect other OSes
    case `uname` in
        *BSD)
        mtime() { echo "`stat -f %Sm -t $timefmt $arc`"; }
        chronological() {
            local input=`cat` # XXX: must be very inefficient :(
            if [ -n "$input" ]; then
                echo "$input" | xargs -0 ls -tr
            fi
        }
        ;;
    esac
    extract_from() {
        local arc=$1
        case "$arc" in
            *.tar.gz)  untar "$arc" -z                          ;;
            *.tar.bz2) untar "$arc" -j                          ;;
            *.tar)     untar "$arc"                             ;;
            # TODO rememeber and reuse passphrase for key?
            *.tar.gpg) gpg --quiet --decrypt "$arc" | untar -   ;;
            *) error "$arc: not supported"; return 0 ;;
        esac
    }
    try_recovery() {
        # find requested files which may be in this archive series
        local p a qs; qs=()
        for p in `eval "echo $paths"`; do
            for a in "${Args[@]}"; do
                [ `expr "$a" : "$p"` -eq ${#p} ] ||
                [ `expr "$p" : "$a"` -eq ${#a} ] || continue
                qs=("${qs[@]}" "${a#/}")
            done
        done
        [ ${#qs[@]} -gt 0 ] || return 0
        echo -n "$prefix: recovering ${qs[@]}"
        # find the base archive (the most recent one)
        local arc=`find "$prefix-"*.0.* -type f ! -newer "$timestamp" \
                    -print0 2>/dev/null | chronological | tail -1`
        local period=${arc%.0.*}
        if ! [ -f "$arc" ]; then
            error "$prefix: none exists for $when"
            return 0
        fi
        # TODO: check list of deleted files?
        untar() { tar -C "$Here" -vxpf "$@" "${qs[@]}"; }
        # and extract files from successive archives
        echo " from $period.*.*"
        while [ -f "$arc" ]; do
            # extract from $arc
            echo " searching $arc (`mtime "$arc"`) (skip = ^\\)"
            set +e; extract_from "$arc"; set -e
            # pick the next oldest one for arc
            arc=`find "$period".*.* -type f \
                    -newer "$arc" ! -newer "$timestamp" \
                    -print0 2>/dev/null | chronological | head -1`
        done
    }

    foreach_backup try_recovery
    exit 0
    ;;
esac

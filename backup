#!/usr/bin/env bash
# girok -- backup manager
# Author: Jaeho Shin <netj@sparcs.org>
# Refined: 2006-04-06
# Created: 2004-08-24

set -e
. "`dirname "$0"`/.girok.sh"

BackupTmp=${BackupTmp:-$Base}; export BackupTmp
BackupRoot=${BackupRoot:-$Base}
BackupArchive=${BackupArchive:-$BackupRoot/archive}
BackupTable=${BackupTable:-$BackupRoot/backuptab}

foreach_backup() {
    local line=0 rest= prefix= period= options= paths=
    while read; do
        let ++line
        [ "$REPLY" = "${REPLY#\#}" -o -z "$REPLY" ] || continue
        rest=$REPLY
        prefix=${rest%%	*}
        rest=${rest#$prefix	}
        periodspec=${rest%%	*}
        rest=${rest#$periodspec	}
        options=${rest%%	*}
        paths=${rest#$options	}
        if [ -n "$prefix" -a -n "$periodspec" -a -n "$paths" ]; then
            "$@"
        else
            echo "$BackupTable: line $line: syntax error" >&2
        fi
    done <"$BackupTable"
}

case "$Name" in
    backup)
    usage() {
        cat <<EOF
girok $Version -- perform backup
Usage: backup { <prefix> }

Create backup archives for <prefix>es defined in $BackupTable.
Each line in $BackupTable defines an archive series.  Each must have four
fields separated by tab character: prefix, period, options, and paths.
Lines that begin with a \# are ignored.  Each archive is created under
$BackupArchive/ with the specified prefix, period, and options by girok(1).

For example, the following defines an archive series that will be stored as
$BackupArchive/home/netj-*-*.tar.gpg.
-->8--
home/netj	%m/3	-e netj	/home/netj
--8<--
See girok(1) for more information about periods and options.
EOF
        [ $# -gt 0 ] && err "$@"
        exit 2
    }
    [ $# -eq 0 ] && usage

    finish() {
        local exitcode=$?
        trap "exit $exitcode" EXIT ERR HUP INT TERM
        rm -f $tmp
        echo "ends   at `date +'%F %T %z'`"
        exit $exitcode
    }
    # prepare output holder
    tmp=`mktemp /tmp/backup.XXXXXX`
    trap finish EXIT ERR HUP INT TERM

    cd "$BackupArchive"
    failure=0
    do_backup() {
        local a=
        for a in "${Args[@]}"; do
            [ `expr "$prefix" : "$a"` -eq ${#prefix} ] || continue
            printf "* %-16s" "$prefix:"
            if eval "'${Base/"'"/"'\\''"}'/girok $options \
                    $prefix $periodspec $paths" >$tmp 2>&1; then
                printf "%28s %5s" \
                    `grep 'containing:$' $tmp | sed -e 's/(\([^)]*\)).*/\1/'`
                head -10 $tmp | grep completed: | sed -e 's/^.*://'
            else
                echo FAILED
                let ++failure
                cat $tmp 2>/dev/null
            fi
        done
    }

    echo "girok $Version"
    echo "backup ${Args[@]}"
    echo "begins at `date +'%F %T %z'`"
    echo

    echo "= backups ="
    foreach_backup do_backup
    echo

    echo "= disk usages ="
    df -h `find "$BackupArchive/" -type d` \
    | tail +2 | sort | uniq | sed -e 's/^/* /'
    echo

    exit $failure
    ;;


    recover)
    usage() {
        cat <<EOF
girok $Version -- recover files
Usage: recover [ -t [[CC]YY]MMDDhhmm[.ss] ] { <path> }

Finds and extracts given paths from backup archives,
from the most recent backup before the given time.
Current date and time are used if not specified.
EOF
        [ $# -gt 0 ] && err "$@"
        exit 2
    }
    # process options
    while getopts "t:" o; do
        case "$o" in
            t) when=$OPTARG ;;
        esac
    done
    shift $(($OPTIND - 1))
    [ $# -eq 0 ] && usage

    cd "$BackupArchive"
    when=${when:-`date +%Y%m%d%H%M.%S`}
    # prepare timestamp
    timestamp=`mktemp /tmp/recover.XXXXXX`
    trap "rm -f $timestamp" EXIT ERR HUP INT TERM
    touch -m -t $when $timestamp 2>/dev/null ||
        usage "specify time in [[CC]YY]MMDDhhmm[.ss]"

    extract_from() {
        local arc=$1
        case "$arc" in
            *.tar.gz)  untar "$arc" -z                          ;;
            *.tar.bz2) untar "$arc" -j                          ;;
            *.tar)     untar "$arc"                             ;;
            # TODO rememeber and reuse passphrase for key?
            *.tar.gpg) gpg --quiet --decrypt "$arc" | untar -   ;;
            *) err "$arc: not supported"; return 0 ;;
        esac
    }
    try_recovery() {
        # find requested files which may be in this archive series
        local p a qs; qs=()
        for p in `eval "echo $paths"`; do
            for a in "${Args[@]}"; do
                [ `expr "$a" : "$p"` -eq ${#p} ] ||
                [ `expr "$p" : "$a"` -eq ${#a} ] || continue
                qs=("${qs[@]}" "${a#/}")
            done
        done
        [ ${#qs[@]} -gt 0 ] || return 0
        echo -n "$prefix: recovering ${qs[@]}"
        # find the base archive (the most recent one)
        local arc=`find "$prefix-"*.0.* -type f ! -newer "$timestamp" \
                    -print0 2>/dev/null | chronological | tail -1`
        local period=${arc%.0.*}
        if ! [ -f "$arc" ]; then
            err "$prefix: none exists for $when"
            return 0
        fi
        # TODO: check list of deleted files?
        untar() { tar -C "$Here" -vxpf "$@" "${qs[@]}"; }
        # and extract files from successive archives
        echo " from $period.*.*"
        while [ -f "$arc" ]; do
            # extract from $arc
            echo " searching $arc (`mtime "$arc"`) (skip = ^\\)"
            set +e; extract_from "$arc"; set -e
            # pick the next oldest one for arc
            arc=`find "$period".*.* -type f \
                    -newer "$arc" ! -newer "$timestamp" \
                    -print0 2>/dev/null | chronological | head -1`
        done
    }

    foreach_backup try_recovery
    exit 0
    ;;
esac

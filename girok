#!/usr/bin/env bash
# girok -- incremental backup script
  Version=1.20060503
# Author: Jaeho Shin <netj@sparcs.org>
# Refined: 2006-04-06
# Created: 2003-10-29

usage() {
    cat <<EOF
girok $Version
Usage: girok { <option> } <prefix> %fmt/# { <path> | <option-for-tar> }

Option:
  -h          show this usage
  -o user     owner of the backup
  -g group    owner group of the backup
  -m mode     access mode for the backup
  -e keyid    compress and encrypt with GnuPG
  -j          compress with bzip2
  -z          compress with gzip

Period:
  You must specify a rotation period as "%fmt/#".
  "%fmt" is the format string used in date, e.g. %m, %U, %d, and
  "#" is the number of periods to keep until next rotation.

  Path where to place the backup is determined by appending
  \`date +%fmt\` to <prefix>, i.e. "<prefix>-\`date +%fmt\`".
  For example, "%U/4" means, restart every week and keep them for 3 weeks,
  and "%m/6" means, restart every month and keep them for 5 months.

Environment Variable:
  * TMPDIR for directory that will hold temporary files
  * GNUPGHOME or HOME for encryption
EOF
    exit 2
}

set -e

# default options
umask 077
ulimit -c 0
mode="a=,ug=r"
owner="backup"
group="backup"
encrypt=false
encrypt_key=
compress_type=gzip

# process options
while getopts "hm:o:zjirp:e:" c; do
    case "$c" in
        z) compress_type=gzip ;;
        j) compress_type=bzip2 ;;
        e) encrypt=true; encrypt_key=$OPTARG ;;
        o) owner=$OPTARG ;;
        g) group=$OPTARG ;;
        m) mode=$OPTARG ;;
        h) usage ;;
    esac
done
shift $(($OPTIND - 1))
[ $# -lt 3 ] && usage
prefix=$1 periodspec=$2; shift 2
paths=("$@")


# check environment
err() { echo "girok: $@" >&2; exit 1; }
if $encrypt; then
    if ! [ -d "$HOME/.gnupg" -o -d "$GNUPGHOME" ]; then
        err "For encryption, HOME or at least GNUPGHOME must be set"
    fi
    # TODO: existence of gpg key
fi
# TODO: existence of owner, group


# some useful pieces
cleanup() {
    exitcode=$?
    trap "exit $exitcode" EXIT ERR HUP INT TERM
    [ -f "$tmp/err" ] && cat "$tmp/err" >&2
    rm -rf "$tmp"
}
is_root() { [ $EUID -eq 0 ]; }
set_attr() {
    local f=
    for f in "$@"; do
        [ -e "$f" ] || continue
        is_root && chown -f $owner "$f"
        chgrp -f $group "$f"
        chmod -f $mode "$f"
    done
}


# some variables
suffix="tar"
taropts=()
addtaropt() { taropts=("${taropts[@]}" "$@"); }
# process encrypt/compress option
if $encrypt; then
    suffix="tar.gpg"
else
    case "$compress_type" in
        bzip2) addtaropt -j; suffix="tar.bz2" ;;
        gzip)  addtaropt -z; suffix="tar.gz" ;;
        "")    ;;
        *)     echo unknown compress type: $compress_type >&2; exit 4 ;;
    esac
fi


# prepare a directory safe to play with
tmp=`mktemp -d "${TMPDIR:-.}/girok.XXXXXX"`
trap cleanup EXIT ERR HUP INT TERM
# determine current period
periodfmt=${periodspec%/*}
periodcnt=${periodspec#*/}
period=`date +"$periodfmt" | sed -e 's/^0*//g'`
period=`printf "%0${#periodcnt}d" $(($period % $periodcnt))`
# determine whether to restart or not
if [ "$period@$periodspec" != "`cat "$prefix.last" 2>/dev/null`" ]; then
    echo "$period@$periodspec" >"$tmp/last"
    restart=true
else
    restart=false
fi
# prepare incremental timestamp
touch "$tmp/inc"
addtaropt -g "$tmp/inc"
$restart || cp -pf "$prefix.inc" "$tmp/inc"
chmod +w "$tmp/inc"


# put everything into the archive
justtar() {
    tar -cvf - "${taropts[@]}" "${paths[@]}" 2>"$tmp/err"
}
encrypttar() {
    justtar | \
    gpg --encrypt --batch --quiet --always-trust --default-recipient-self \
        ${encrypt_key:+--recipient "$encrypt_key"}
}
tarcmd=justtar
$encrypt && tarcmd=encrypttar
if ! $tarcmd >"$tmp/arc"; then
    # TODO: handle more error conditions
    [ -s "$tmp/arc" ] || exit 4
fi
# TODO: maintain a file list, or list of deleted files


# determine sub-period id
id=0
if ! $restart; then
    # find base
    arc=`find "$prefix-$period.0".* -type f | head -1`
    while [ -f "$arc" ]; do
        let ++id
        # find an incremental archive having this id
        if find "$prefix-$period.$id".* -type f -newer "$arc" \
            -print0 2>/dev/null >"$tmp/found" && [ -s "$tmp/found" ]; then
            arc=`xargs -0 ls -tr <"$tmp/found" | head -1`
        else
            break
        fi
    done
    rm -f "$tmp/found"
fi
arc="$prefix-$period.$id.$suffix"
# put it in the right place
set_attr "$tmp/arc" "$tmp/inc" "$tmp/last"
mkdir -p -m 755 "`dirname "$prefix"`"
if $restart; then
    rm -f "$prefix-$period".*.*
    mv -f "$tmp/last" "$prefix.last"
fi
mv -f "$tmp/arc" "$arc"
mv -f "$tmp/inc" "$prefix.inc"


# finish message
echo -n "Backup completed:"
$restart && echo -n " restarted" || echo -n " incremental"
$encrypt && echo -n " encrypted"
echo
echo "$arc (`du -h "$arc" | cut -f1`) containing:"
if $restart; then
    # show given arguments (instead of whole list)
    for i in "$@"; do echo "$i"; done
else
    # show changed(stderr output of tar), so backup'ed files but no directories
    grep -v /$ "$tmp/err"
fi
rm -f "$tmp/err"


exit 0
